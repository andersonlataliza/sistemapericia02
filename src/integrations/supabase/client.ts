// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = String(import.meta.env.VITE_SUPABASE_URL || '').trim();
const SUPABASE_PUBLISHABLE_KEY = String(
  import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY || import.meta.env.VITE_SUPABASE_ANON_KEY || ''
).trim();

export const isSupabaseConfigured = Boolean(SUPABASE_URL && SUPABASE_PUBLISHABLE_KEY);

const supabaseConfigErrorMessage =
  'Supabase config missing: set VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY (or VITE_SUPABASE_ANON_KEY)';

const makeDisabledError = () => ({
  message: supabaseConfigErrorMessage,
});

const makeDisabledResponse = () => ({
  data: null,
  error: makeDisabledError(),
});

const makeDisabledBuilder = () => {
  const builder: any = {};
  const chain = () => builder;

  builder.select = chain;
  builder.eq = chain;
  builder.neq = chain;
  builder.gt = chain;
  builder.gte = chain;
  builder.lt = chain;
  builder.lte = chain;
  builder.like = chain;
  builder.ilike = chain;
  builder.in = chain;
  builder.is = chain;
  builder.not = chain;
  builder.contains = chain;
  builder.containedBy = chain;
  builder.overlaps = chain;
  builder.order = chain;
  builder.range = chain;
  builder.limit = chain;
  builder.single = chain;
  builder.maybeSingle = chain;
  builder.insert = chain;
  builder.upsert = chain;
  builder.update = chain;
  builder.delete = chain;

  builder.then = (onFulfilled: any, onRejected: any) =>
    Promise.resolve(makeDisabledResponse()).then(onFulfilled, onRejected);
  builder.catch = (onRejected: any) => Promise.resolve(makeDisabledResponse()).catch(onRejected);
  builder.finally = (onFinally: any) => Promise.resolve(makeDisabledResponse()).finally(onFinally);

  return builder;
};

const createDisabledSupabaseClient = (): SupabaseClient<Database> => {
  const noop = () => {};

  return {
    auth: {
      getSession: async () => ({ data: { session: null }, error: makeDisabledError() }),
      onAuthStateChange: () => ({ data: { subscription: { unsubscribe: noop } } }),
      signInWithPassword: async () => ({ data: { session: null, user: null }, error: makeDisabledError() }),
      signOut: async () => ({ error: makeDisabledError() }),
      resetPasswordForEmail: async () => ({ data: null, error: makeDisabledError() }),
      getUser: async () => ({ data: { user: null }, error: makeDisabledError() }),
    } as any,
    from: () => makeDisabledBuilder(),
    rpc: async () => makeDisabledResponse(),
    functions: {
      invoke: async () => makeDisabledResponse(),
    } as any,
    storage: {
      from: () => ({
        upload: async () => makeDisabledResponse(),
        download: async () => makeDisabledResponse(),
        remove: async () => makeDisabledResponse(),
        list: async () => makeDisabledResponse(),
        getPublicUrl: () => ({ data: { publicUrl: '' } }),
      }),
    } as any,
  } as any;
};

// Singleton pattern to prevent multiple client instances
let supabaseInstance: SupabaseClient<Database> | null = null;

const createSupabaseClient = (): SupabaseClient<Database> => {
  if (supabaseInstance) {
    return supabaseInstance;
  }

  if (!isSupabaseConfigured) {
    supabaseInstance = createDisabledSupabaseClient();
    return supabaseInstance;
  }

  supabaseInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    global: {
      headers: {
        apikey: SUPABASE_PUBLISHABLE_KEY,
      },
    },
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      flowType: 'pkce',
      storageKey: 'pericia-automata-auth'
    }
  });

  const hardSignOut = async () => {
    try {
      await supabaseInstance?.auth.signOut();

      const keysToRemove: string[] = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.includes('supabase') || key.includes('auth') || key.includes('sb-'))) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => localStorage.removeItem(key));
      sessionStorage.clear();
    } catch {
    } finally {
      window.location.href = '/';
    }
  };

  supabaseInstance.auth.onAuthStateChange(async (event) => {
    if (event === 'SIGNED_OUT') {
      await hardSignOut();
    }
  });

  return supabaseInstance;
};

// Export the singleton instance
export const supabase = createSupabaseClient();

// Função para limpar sessão corrompida completamente
export const clearCorruptedSession = async () => {
  try {
    console.log('Clearing corrupted session...');
    
    // Sign out from Supabase
    await supabase.auth.signOut();
    
    // Clear all auth-related items from localStorage
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && (key.includes('supabase') || key.includes('auth') || key.includes('sb-'))) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => localStorage.removeItem(key));
    
    // Clear session storage as well
    sessionStorage.clear();
    
    console.log('Session cleared, redirecting to login...');
    
    // Redirect to login page
    window.location.href = '/';
    
  } catch (error) {
    console.error('Erro ao limpar sessão:', error);
    // Force reload as fallback
    window.location.reload();
  }
};

// Função para verificar e recuperar sessão
export const validateAndRecoverSession = async () => {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('Session validation error:', error);
      const msg = String((error as any)?.message || '').toLowerCase();
      if (msg.includes('refresh_token_not_found') || msg.includes('invalid refresh token')) {
        await clearCorruptedSession();
        return null;
      }
    }
    
    return session;
  } catch (error) {
    console.error('Session recovery error:', error);
    await clearCorruptedSession();
    return null;
  }
};

// Função para obter usuário autenticado com validação
export const getAuthenticatedUser = async () => {
  try {
    const session = await validateAndRecoverSession();
    if (!session) {
      return null;
    }

    const { data: { user }, error } = await supabase.auth.getUser();
    
    if (error) {
      console.error('Get user error:', error);
      if (error.message.includes('JWT') || error.message.includes('token')) {
        await clearCorruptedSession();
        return null;
      }
    }
    
    return user;
  } catch (error) {
    console.error('Authentication error:', error);
    await clearCorruptedSession();
    return null;
  }
};
